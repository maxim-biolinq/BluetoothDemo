// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: source/ble_message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// BLE messaging over GATT
// Gemini Protocol Buffer Service: RX Characteristic, TX Characteristic

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Iris_BLEMessageChRxRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msg: Iris_BLEMessageChRxRequest.OneOf_Msg? = nil

  var info: Iris_InfoRequest {
    get {
      if case .info(let v)? = msg {return v}
      return Iris_InfoRequest()
    }
    set {msg = .info(newValue)}
  }

  var eDataBlock: Iris_EDataBlockRequest {
    get {
      if case .eDataBlock(let v)? = msg {return v}
      return Iris_EDataBlockRequest()
    }
    set {msg = .eDataBlock(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Msg: Equatable, Sendable {
    case info(Iris_InfoRequest)
    case eDataBlock(Iris_EDataBlockRequest)

  }

  init() {}
}

/// TODO or will all Commands actually be Requests?
struct Iris_BLEMessageChRxCommand: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msg: Iris_BLEMessageChRxCommand.OneOf_Msg? = nil

  var startSensor: Iris_StartSensorCommand {
    get {
      if case .startSensor(let v)? = msg {return v}
      return Iris_StartSensorCommand()
    }
    set {msg = .startSensor(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Msg: Equatable, Sendable {
    case startSensor(Iris_StartSensorCommand)

  }

  init() {}
}

struct Iris_BLEMessageChTxResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Will be the seq_num of the RX message request from the App
  /// TODO(srozell) here or later in the transport layer, like with the CRC, seq_num?
  var rspNum: UInt32 = 0

  var msg: Iris_BLEMessageChTxResponse.OneOf_Msg? = nil

  var info: Iris_InfoResponse {
    get {
      if case .info(let v)? = msg {return v}
      return Iris_InfoResponse()
    }
    set {msg = .info(newValue)}
  }

  var eDataBlock: Iris_EDataBlockResponse {
    get {
      if case .eDataBlock(let v)? = msg {return v}
      return Iris_EDataBlockResponse()
    }
    set {msg = .eDataBlock(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Msg: Equatable, Sendable {
    case info(Iris_InfoResponse)
    case eDataBlock(Iris_EDataBlockResponse)

  }

  init() {}
}

struct Iris_BLEMessageChTxEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msg: Iris_BLEMessageChTxEvent.OneOf_Msg? = nil

  var status: Iris_StatusEvent {
    get {
      if case .status(let v)? = msg {return v}
      return Iris_StatusEvent()
    }
    set {msg = .status(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Msg: Equatable, Sendable {
    case status(Iris_StatusEvent)

  }

  init() {}
}

/// Messages exchanged on the RX Characteristic (or channel, "ch" works for both)
/// These are either:
///  1. Unsolicited command messages from the App to the FW (e.g., StartSensor)
///  2. [Not supported] Response messages from the App to the FW (e.g., GetSyncResponse)
///  3. Request messages from the App to the FW (e.g. InfoRequest)
struct Iris_BLEMessageChRx: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msg: Iris_BLEMessageChRx.OneOf_Msg? = nil

  var request: Iris_BLEMessageChRxRequest {
    get {
      if case .request(let v)? = msg {return v}
      return Iris_BLEMessageChRxRequest()
    }
    set {msg = .request(newValue)}
  }

  var command: Iris_BLEMessageChRxCommand {
    get {
      if case .command(let v)? = msg {return v}
      return Iris_BLEMessageChRxCommand()
    }
    set {msg = .command(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Msg: Equatable, Sendable {
    case request(Iris_BLEMessageChRxRequest)
    case command(Iris_BLEMessageChRxCommand)

  }

  init() {}
}

/// Messages exchanged on the TX Characteristic (or channel, "ch" works for both)
/// These are either:
///  1. Unsolicited event messages from the FW to the App (e.g., StatusEvent)
///  2. Response messages from the FW to the App (e.g., InfoResponse)
///  3. [Not supported] Request messages from the FW to the App (e.g., GetSyncRequest)
struct Iris_BLEMessageChTx: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msg: Iris_BLEMessageChTx.OneOf_Msg? = nil

  var response: Iris_BLEMessageChTxResponse {
    get {
      if case .response(let v)? = msg {return v}
      return Iris_BLEMessageChTxResponse()
    }
    set {msg = .response(newValue)}
  }

  var event: Iris_BLEMessageChTxEvent {
    get {
      if case .event(let v)? = msg {return v}
      return Iris_BLEMessageChTxEvent()
    }
    set {msg = .event(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Msg: Equatable, Sendable {
    case response(Iris_BLEMessageChTxResponse)
    case event(Iris_BLEMessageChTxEvent)

  }

  init() {}
}

/// Two unidirectional channels: RX Characteristic and TX Characteristic (named from fw perspective)
/// Each peer can send or receive one message at a time on a channel
///  Note: The send/receive implementation is swapped for each peer (unlike UART wiring)
///  e.g., FW sends on the TX Char, App receives on the TX Char, App sends on the RX Char
/// TODO(srozell) consider removing this wrapper and just using the channels directly?
struct Iris_BLEMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TODO(srozell) here or later in the transport layer, like with the CRC?
  var seqNum: UInt32 = 0

  var channel: Iris_BLEMessage.OneOf_Channel? = nil

  var rxMsg: Iris_BLEMessageChRx {
    get {
      if case .rxMsg(let v)? = channel {return v}
      return Iris_BLEMessageChRx()
    }
    set {channel = .rxMsg(newValue)}
  }

  var txMsg: Iris_BLEMessageChTx {
    get {
      if case .txMsg(let v)? = channel {return v}
      return Iris_BLEMessageChTx()
    }
    set {channel = .txMsg(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Channel: Equatable, Sendable {
    case rxMsg(Iris_BLEMessageChRx)
    case txMsg(Iris_BLEMessageChTx)

  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "iris"

extension Iris_BLEMessageChRxRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BLEMessageChRxRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0\u{3}e_data_block\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Iris_InfoRequest?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .info(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .info(v)
        }
      }()
      case 2: try {
        var v: Iris_EDataBlockRequest?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .eDataBlock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .eDataBlock(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.msg {
    case .info?: try {
      guard case .info(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .eDataBlock?: try {
      guard case .eDataBlock(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iris_BLEMessageChRxRequest, rhs: Iris_BLEMessageChRxRequest) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iris_BLEMessageChRxCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BLEMessageChRxCommand"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}start_sensor\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Iris_StartSensorCommand?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .startSensor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .startSensor(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .startSensor(let v)? = self.msg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iris_BLEMessageChRxCommand, rhs: Iris_BLEMessageChRxCommand) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iris_BLEMessageChTxResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BLEMessageChTxResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}rsp_num\0\u{1}info\0\u{3}e_data_block\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.rspNum) }()
      case 2: try {
        var v: Iris_InfoResponse?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .info(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .info(v)
        }
      }()
      case 3: try {
        var v: Iris_EDataBlockResponse?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .eDataBlock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .eDataBlock(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.rspNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.rspNum, fieldNumber: 1)
    }
    switch self.msg {
    case .info?: try {
      guard case .info(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .eDataBlock?: try {
      guard case .eDataBlock(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iris_BLEMessageChTxResponse, rhs: Iris_BLEMessageChTxResponse) -> Bool {
    if lhs.rspNum != rhs.rspNum {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iris_BLEMessageChTxEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BLEMessageChTxEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{3}status\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try {
        var v: Iris_StatusEvent?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .status(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .status(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .status(let v)? = self.msg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iris_BLEMessageChTxEvent, rhs: Iris_BLEMessageChTxEvent) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iris_BLEMessageChRx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BLEMessageChRx"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}request\0\u{1}command\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Iris_BLEMessageChRxRequest?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .request(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .request(v)
        }
      }()
      case 2: try {
        var v: Iris_BLEMessageChRxCommand?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .command(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .command(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.msg {
    case .request?: try {
      guard case .request(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .command?: try {
      guard case .command(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iris_BLEMessageChRx, rhs: Iris_BLEMessageChRx) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iris_BLEMessageChTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BLEMessageChTx"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}response\0\u{1}event\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Iris_BLEMessageChTxResponse?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .response(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .response(v)
        }
      }()
      case 2: try {
        var v: Iris_BLEMessageChTxEvent?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .event(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .event(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.msg {
    case .response?: try {
      guard case .response(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .event?: try {
      guard case .event(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iris_BLEMessageChTx, rhs: Iris_BLEMessageChTx) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iris_BLEMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BLEMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}seq_num\0\u{3}rx_msg\0\u{3}tx_msg\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seqNum) }()
      case 2: try {
        var v: Iris_BLEMessageChRx?
        var hadOneofValue = false
        if let current = self.channel {
          hadOneofValue = true
          if case .rxMsg(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.channel = .rxMsg(v)
        }
      }()
      case 3: try {
        var v: Iris_BLEMessageChTx?
        var hadOneofValue = false
        if let current = self.channel {
          hadOneofValue = true
          if case .txMsg(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.channel = .txMsg(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.seqNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.seqNum, fieldNumber: 1)
    }
    switch self.channel {
    case .rxMsg?: try {
      guard case .rxMsg(let v)? = self.channel else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .txMsg?: try {
      guard case .txMsg(let v)? = self.channel else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iris_BLEMessage, rhs: Iris_BLEMessage) -> Bool {
    if lhs.seqNum != rhs.seqNum {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
